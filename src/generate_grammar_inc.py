#!/usr/bin/env python3

import json
import errno
import os.path

kIndent = '    '

def make_path_to_file(f):
    """Makes all ancestor directories to the given file, if they
    don't yet exist.

    Arguments:
        f: The file whose ancestor directories are to be created.
    """
    dir = os.path.dirname(os.path.abspath(f))
    try:
        os.makedirs(dir)
    except OSError as e:
        if e.errno == errno.EEXIST and os.path.isdir(dir):
            pass
        else:
            raise

def init_operand_kinds_map(grammar_json):
    if 'operand_kinds' not in grammar_json:
        return {}
    
    operand_kinds_json = grammar_json['operand_kinds']
    
    operand_kinds_map = {}
    for operand_kind in operand_kinds_json:
        kind = operand_kind['kind']
        if kind in operand_kinds_map:
            raise Exception('Duplicated operand kind: ' + kind)
        
        operand_kinds_map[kind] = operand_kind
        
    return operand_kinds_map

def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Generate a 010Editor template "include" file from a JSON grammar file, which can be used to parse SPIR-V instructions.')
    
    parser.add_argument('--grammar', type=str, required=True, help='Path to the JSON grammar file')
    parser.add_argument('--output', type=str, required=True, help='Path to the output file')
    
    args = parser.parse_args()
    
    parts = []
    parts.append('// This file is generated by ' +  os.path.basename(__file__) + '\n')
    parts.append('#include "spirv_inc.bt"\n')
    parts.append('typedef uint32 SpvWord_t;\n')
    
    with open(args.grammar) as json_file:
        grammar_json = json.loads(json_file.read())
        #operand_kinds_map = init_operand_kinds_map(grammar_json)
        
        if 'operand_kinds' in grammar_json:
            for operand_kind in grammar_json['operand_kinds']:
                kind = operand_kind['kind']
                category = operand_kind['category']
                
                parts.append('typedef struct SpvOperand' + kind + '_ (int64 endOffset) ' + '{')
                
                if category == 'ValueEnum':
                    parts.append(kIndent + 'Spv' + kind + ' value;')
                elif category == 'BitEnum':
                    parts.append(kIndent + 'Spv' + kind + 'Mask' + ' value;')
                elif category == 'Id':
                    parts.append(kIndent + 'SpvId value;')
                elif category == 'Literal':
                    if kind == 'LiteralInteger':
                        parts.append(kIndent + 'uint32 value;')
                        
                    elif kind == 'LiteralString':
                        parts.append(kIndent + 'string value;')
                        parts.append(kIndent + 'local int64 fpos = FTell();')
                        parts.append(kIndent + 'fpos = (fpos + sizeof(SpvWord_t) - 1) & ~(sizeof(SpvWord_t)-1);')
                        parts.append(kIndent + 'FSeek(fpos);')
                    elif kind == 'LiteralFloat':
                        parts.append(kIndent + 'float value;')
                    elif kind == 'LiteralContextDependentNumber':
                        parts.append(kIndent + 'local int64 fpos = FTell();')
                        parts.append(kIndent + 'local int64 len = endOffset - fpos;')
                        parts.append(kIndent + 'byte value[len];')
                    elif kind == 'LiteralExtInstInteger':
                        parts.append(kIndent + 'uint32 value;')
                    elif kind == 'LiteralSpecConstantOpInteger':
                        parts.append(kIndent + 'uint32 value;')
                        parts.append(kIndent + 'local int64 fpos = FTell();')
                        parts.append(kIndent + 'local int64 len = endOffset - fpos;')
                        parts.append(kIndent + 'byte operands[len];')
                    else:
                        assert False, 'Unknown kind: ' + kind
                elif category == 'Composite':
                    bases = operand_kind['bases']
                    idx = 0
                    for base in bases:
                        parts.append(kIndent + 'SpvOperand' + base + '_t value' + str(idx) + ';')
                        idx += 1
                else:
                    assert False, 'Unknown category: ' + category
                    
                parts.append('} SpvOperand' + kind + '_t;\n')
                
                if 'enumerants' in operand_kind:
                    for enumerant in operand_kind['enumerants']:
                        pass
        
        if 'instructions' in grammar_json:
            # print ParseOperandsSpv<OpcodeName> functions per opcode
            for instruction in grammar_json['instructions']:
                opname = 'Spv' + instruction['opname']
                parts.append('void ParseOperands' + opname + '(int64 endOffset) {')
                
                if 'operands' in instruction:
                    operand_idx = 0
                    for operand in instruction['operands']:
                        curr_indent = kIndent
                        is_optional = 'quantifier' in operand and operand['quantifier'] == '?'
                        is_variadic = 'quantifier' in operand and operand['quantifier'] == '*'
                        
                        if is_optional:
                            parts.append(curr_indent + 'if (FTell() < endOffset) {')
                            curr_indent = kIndent * 2
                        elif is_variadic:
                            parts.append(curr_indent + 'while (FTell() < endOffset) {')
                            curr_indent = kIndent * 2
                        
                        kind = operand['kind']
                        operand_type = 'SpvOperand' + kind + '_t'
                        operand_name = 'operand' + str(operand_idx) if not is_variadic else 'operandVariadic' + str(operand_idx)
                        
                        # TODO: template attribute for comments
                        parts.append(curr_indent + operand_type + ' ' + operand_name + '(endOffset);')
                        
                        if is_optional:
                            curr_indent = kIndent
                            parts.append(curr_indent + '}')
                        elif is_variadic:
                            curr_indent = kIndent
                            parts.append(curr_indent + '}')
                        
                        operand_idx += 1
                
                parts.append('}\n')          
            
            # print ParseOperands(SpvOp opcode, int64 endOffset) function
            parts.append('void ParseOperands(SpvOp opcode, int64 endOffset) {')
            parts.append(kIndent + 'switch (opcode) {')
            
            for instruction in grammar_json['instructions']:
                opname = 'Spv' + instruction['opname']
                parts.append(kIndent*2 + 'case ' + opname + ':') 
                parts.append(kIndent*2 + '{')
                parts.append(kIndent*3 + 'ParseOperands' + opname + '(endOffset);')
                parts.append(kIndent*3 + kIndent + 'break;')
                parts.append(kIndent*2 + '}')

            
    parts.append(kIndent * 2 + 'default:')
    parts.append(kIndent * 2 + 'Assert(false, "Unknown opcode: " + opcode);')
    parts.append(kIndent * 2 + '    break;')
    parts.append(kIndent + '}')
    parts.append('}')    
    
    make_path_to_file(args.output)
    
    with open(args.output, 'w') as output_file:
        output_file.write('\n'.join(parts))

if __name__ == '__main__':
    main()